<!--<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - materials - cube reflection [cars]</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background:#000;
				color:#fff;
				padding:0;
				margin:0;
				overflow:hidden;
				font-family:georgia;
				text-align:center;
			}
			a { color:skyblue; text-decoration:none }
			#info {
				position: absolute;
				width: 100%;
			}
		</style>
	</head>

	<body>		
		<script src="https://rawgit.com/mrdoob/three.js/master/build/three.js"></script>
		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js"></script>
		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/libs/dat.gui.min.js"></script>

		<div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl environment mapping example<br/>
			Equirectangular Map by <a href="http://gl.ict.usc.edu/Data/HighResProbes/">University of Southern California</a><br/>
			Spherical Map by <a href="http://www.pauldebevec.com/Probes/">Paul Debevec</a>
		</div>

		<script>
			var controls, camera, scene, renderer;
			var cameraCube, sceneCube;
			var textureEquirec, textureCube, textureSphere;
			var cubeMesh, sphereMesh;
			var sphereMaterial;
			var refract;
			init();
			animate();
			function init() {
				// CAMERAS
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 100000 );
				camera.position.set( 0, 0, 1000 );
				cameraCube = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 100000 );
				controls = new THREE.OrbitControls( camera );
				controls.minDistance = 500;
				controls.maxDistance = 2500;
				// SCENE
				scene = new THREE.Scene();
				sceneCube = new THREE.Scene();
				// Lights
				var ambient = new THREE.AmbientLight( 0xffffff );
				scene.add( ambient );
				// Textures
				var r = "";
				var urls = [ r + "px.png", r + "nx.png",
						 r + "py.png", r + "ny.png",
						 r + "pz.png", r + "nz.png" ];
				textureCube = new THREE.CubeTextureLoader().load( urls );
				textureCube.format = THREE.RGBFormat;
				textureCube.mapping = THREE.CubeReflectionMapping;
				var textureLoader = new THREE.TextureLoader();
				textureEquirec = textureLoader.load( "tex.png" );
				textureEquirec.mapping = THREE.EquirectangularReflectionMapping;
				textureEquirec.magFilter = THREE.LinearFilter;
				textureEquirec.minFilter = THREE.LinearMipMapLinearFilter;
				textureSphere = textureLoader.load( "metal.jpg" );
				textureSphere.mapping = THREE.SphericalReflectionMapping;
				// Materials
				var equirectShader = THREE.ShaderLib[ "equirect" ];
				var equirectMaterial = new THREE.ShaderMaterial( {
					fragmentShader: equirectShader.fragmentShader,
					vertexShader: equirectShader.vertexShader,
					uniforms: equirectShader.uniforms,
					depthWrite: false,
					side: THREE.BackSide
				} );
				equirectMaterial.uniforms[ "tEquirect" ].value = textureEquirec;
				var cubeShader = THREE.ShaderLib[ "cube" ];
				var cubeMaterial = new THREE.ShaderMaterial( {
					fragmentShader: cubeShader.fragmentShader,
					vertexShader: cubeShader.vertexShader,
					uniforms: cubeShader.uniforms,
					depthWrite: false,
					side: THREE.BackSide
				} );
				cubeMaterial.uniforms[ "tCube" ].value = textureCube;
				// Skybox
				cubeMesh = new THREE.Mesh( new THREE.BoxBufferGeometry( 100, 100, 100 ), cubeMaterial );
				sceneCube.add( cubeMesh );
				//
				var geometry = new THREE.SphereBufferGeometry( 400.0, 48, 24 );
				sphereMaterial = new THREE.MeshLambertMaterial( { envMap: textureCube } );
				sphereMesh = new THREE.Mesh( geometry, sphereMaterial );
				scene.add( sphereMesh );
				//
				renderer = new THREE.WebGLRenderer();
				renderer.autoClear = false;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				//renderer.setFaceCulling( THREE.CullFaceNone );
				document.body.appendChild( renderer.domElement );
				//
				var params = {
					Cube: function () {
						cubeMesh.material = cubeMaterial;
						cubeMesh.visible = true;
						sphereMaterial.envMap = textureCube;
						sphereMaterial.needsUpdate = true;
					},
					Equirectangular: function () {
						cubeMesh.material = equirectMaterial;
						cubeMesh.visible = true;
						sphereMaterial.envMap = textureEquirec;
						sphereMaterial.needsUpdate = true;
					},
					Spherical: function () {
							cubeMesh.visible = false;
						sphereMaterial.envMap = textureSphere;
						sphereMaterial.needsUpdate = true;
					},
					Refraction: false
				};
				var gui = new dat.GUI();
				gui.add( params, 'Cube' );
				gui.add( params, 'Equirectangular' );
				gui.add( params, 'Spherical' );
				gui.add( params, 'Refraction' ).onChange( function( value ) {
					if ( value ) {
						textureEquirec.mapping = THREE.EquirectangularRefractionMapping;
						textureCube.mapping = THREE.CubeRefractionMapping;
					} else {
						textureEquirec.mapping = THREE.EquirectangularReflectionMapping;
						textureCube.mapping = THREE.CubeReflectionMapping;
					}
					sphereMaterial.needsUpdate = true;
				} );
				gui.open();
				window.addEventListener( 'resize', onWindowResize, false );
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				cameraCube.aspect = window.innerWidth / window.innerHeight;
				cameraCube.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			//
			function animate() {
				requestAnimationFrame( animate );
				render();
				controls.update();
			}
			function render() {
				var timer = -0.0002 * Date.now();
				camera.lookAt( scene.position );
				cameraCube.rotation.copy( camera.rotation );
				renderer.render( sceneCube, cameraCube );
				renderer.render( scene, camera );
			}
		</script>

	</body>
</html>










<!--<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - postprocessing backgrounds</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				background-color: #000;
				overflow: hidden;
				font-family:Monospace;
				font-size:13px;
				margin: 0px;
				text-align:center;
				overflow: hidden;
			}
			a { color: #88f; }
			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				display:block;
			}
		</style>
	</head>
	<body>
		<div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - Backgrounds: ClearPass, TexturePass and CubeTexturePass by <a href="https://clara.io" target="_blank" rel="noopener">Ben Houston</a>
		</div>

		<div id="container"></div>

		<script src="https://rawgit.com/mrdoob/three.js/master/build/three.js"></script>
		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/libs/stats.min.js"></script>
		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/libs/dat.gui.min.js"></script>

		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/shaders/CopyShader.js"></script>

		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/postprocessing/EffectComposer.js"></script>
		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/postprocessing/ClearPass.js"></script>
		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/postprocessing/RenderPass.js"></script>
		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/postprocessing/TexturePass.js"></script>
		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/postprocessing/CubeTexturePass.js"></script>
		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/postprocessing/ShaderPass.js"></script>

		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js"></script>

		<script>
			var scene, renderer, composer;
			var clearPass, texturePass, renderPass;
			var cameraP, cubeTexturePassP;
			//var cameraO, cubeTexturePassO;
			var gui, stats, texture;
			var params = {
				clearPass: true,
				clearColor: 'white',
				clearAlpha: 1.0,
				texturePass: true,
				texturePassOpacity: 1.0,
				cubeTexturePass: true,
				cubeTexturePassOpacity: 1.0,
				renderPass: true
				//autoRotate: true,
				//camera: 'perspective'
			};
			init();
			animate();
			clearGui();
			function clearGui() {
				if ( gui ) gui.destroy();
				gui = new dat.GUI();
				gui.add( params, "clearPass" );
				gui.add( params, "clearColor", [ 'black', 'white', 'blue', 'green', 'red', 'break' ] );
				gui.add( params, "clearAlpha", 0, 1 );
				gui.add( params, "texturePass" );
				gui.add( params, "texturePassOpacity", 0, 1 );
				gui.add( params, "cubeTexturePass" );
				gui.add( params, "cubeTexturePassOpacity", 0, 1 );
				gui.add( params, "renderPass" );
				//gui.add( params, "autoRotate" );
				//gui.add( params, 'camera', [ 'perspective', 'orthographic' ] );
				gui.open();
			}
			function init() {
				var container = document.getElementById( "container" );
				var width = window.innerWidth || 1;
				var height = window.innerHeight || 1;
				var aspect = width / height;
				var devicePixelRatio = window.devicePixelRatio || 1;
				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setPixelRatio( devicePixelRatio );
				renderer.setSize( width, height );
				document.body.appendChild( renderer.domElement );
				stats = new Stats();
				container.appendChild( stats.dom );
				//
				cameraP = new THREE.PerspectiveCamera( 65, aspect, 1, 10 );
				cameraP.position.z = 7;
			//	cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 3, 10 );
			//	cameraO.position.z = 7;
			//	var fov = THREE.Math.degToRad( cameraP.fov );
			//	var hyperfocus = ( cameraP.near + cameraP.far ) / 2;
			//	var _height = 2 * Math.tan( fov / 2 ) * hyperfocus;
			//	cameraO.zoom = height / _height;
				scene = new THREE.Scene();
				var group = new THREE.Group();
				scene.add( group );
				var light = new THREE.PointLight( 0xddffdd, 1.0 );
				light.position.z = 70;
				light.position.y = -70;
				light.position.x = -70;
				scene.add( light );
				var light2 = new THREE.PointLight( 0xffdddd, 1.0 );
				light2.position.z = 70;
				light2.position.x = -70;
				light2.position.y = 70;
				scene.add( light2 );
				var light3 = new THREE.PointLight( 0xddddff, 1.0 );
				light3.position.z = 70;
				light3.position.x = 70;
				light3.position.y = -70;
				scene.add( light3 );
				var geometry = new THREE.SphereBufferGeometry( 1, 48, 24 );
				var material = new THREE.MeshStandardMaterial();
				material.roughness = 0.5 * Math.random() + 0.25;
				material.metalness = 0;
				material.color.setHSL( Math.random(), 1.0, 0.3 );
				var mesh = new THREE.Mesh( geometry, material );
				group.add( mesh );
				// postprocessing
				var genCubeUrls = function( prefix, postfix ) {
					return [
						prefix + 'px' + postfix, prefix + 'nx' + postfix,
						prefix + 'py' + postfix, prefix + 'ny' + postfix,
						prefix + 'pz' + postfix, prefix + 'nz' + postfix
					];
				};
				composer = new THREE.EffectComposer( renderer );
				clearPass = new THREE.ClearPass( params.clearColor, params.clearAlpha );
				//composer.addPass( clearPass );
				texturePass = new THREE.TexturePass();
				composer.addPass( texturePass );
				var textureLoader = new THREE.TextureLoader();
				textureLoader.load( "testDevice.png", function( map ) {
					texturePass.map = map;
					texturePass.transparent = true;
				});
				cubeTexturePassP = new THREE.CubeTexturePass( cameraP );
				composer.addPass( cubeTexturePassP );
				var ldrUrls = genCubeUrls( "", ".png" );
				new THREE.CubeTextureLoader().load( ldrUrls, function ( ldrCubeMap ) {
					cubeTexturePassP.envMap = ldrCubeMap;
					console.log( "loaded envmap");
				});
				renderPass = new THREE.RenderPass( scene, cameraP );
				renderPass.clear = false;
				composer.addPass( renderPass );
				var copyPass = new THREE.ShaderPass( THREE.CopyShader );
				copyPass.renderToScreen = true;
				composer.addPass( copyPass );
				var controls = new THREE.OrbitControls( cameraP, renderer.domElement );
				controls.target.set( 0, 0, 0 );
				controls.update();
				window.addEventListener( 'resize', onWindowResize, false );
			}
			function onWindowResize() {
				var width = window.innerWidth;
				var height = window.innerHeight;
				var aspect = width / height;
				cameraP.aspect = aspect;
				cameraP.updateProjectionMatrix();
				/*cameraO.left = - height * aspect;
				cameraO.right = height * aspect;
				cameraO.top = height;
				cameraO.bottom = - height;
				cameraO.updateProjectionMatrix();*/
				renderer.setSize( width, height );
				var pixelRatio = renderer.getPixelRatio();
				var newWidth  = Math.floor( width / pixelRatio ) || 1;
				var newHeight = Math.floor( height / pixelRatio ) || 1;
				composer.setSize( newWidth, newHeight );
			}
			function animate() {
				requestAnimationFrame( animate );
				stats.begin();
				cameraP.updateMatrixWorld( true );
				var newColor = clearPass.clearColor;
				switch( params.clearColor ) {
					case 'blue': newColor = 0x0000ff; break;
					case 'red': newColor = 0xff0000; break;
					case 'green': newColor = 0x00ff00; break;
					case 'white': newColor = 0xffffff; break;
					case 'black': newColor = 0x000000; break;
					case 'break': newColor = 0xFFFF00AF; break;
				}
				clearPass.enabled = params.clearPass;
				clearPass.clearColor = newColor;
				clearPass.clearAlpha = params.clearAlpha;
				texturePass.enabled = params.texturePass;
				texturePass.opacity = params.texturePassOpacity;
				cubeTexturePassP.enabled = params.cubeTexturePass;
				cubeTexturePassP.opacity = params.cubeTexturePassOpacity;
				renderPass.enabled = params.renderPass;
				composer.render();
				stats.end();
			}
		</script>
	</body>
</html>-->



<!--<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - materials - shaders [Fresnel]</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background:#000;
				padding:0;
				margin:0;
				font-weight: bold;
				overflow:hidden;
			}
			#info {
				position: absolute;
				top: 0px; width: 100%;
				color: #ffffff;
				padding: 5px;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				z-index:1000;
			}
			a {	color: #ffffff;	}
			#oldie a { color:#0b0 }
		</style>
	</head>

	<body>

		<div id="info"><a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl cube Fresnel shader demo. texture by <a href="http://www.humus.name/index.php?page=Textures" target="_blank" rel="noopener">Humus</a> </div>

		<script src="https://rawgit.com/mrdoob/three.js/master/build/three.js"></script>

		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/shaders/FresnelShader.js"></script>

		

		<script>
			//if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
			var container;
			var camera, scene, renderer;
			var mesh, zmesh, lightMesh, geometry;
			var spheres = [];
			var directionalLight, pointLight;
			var mouseX = 0, mouseY = 0;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			init();
			animate();
			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 100000 );
				camera.position.z = 3200;
				
				
				
				//
				var path = "";
				var format = '.png';
				var urls = [
						path + 'px' + format, path + 'nx' + format,
						path + 'py' + format, path + 'ny' + format,
						path + 'pz' + format, path + 'nz' + format
					];
				var textureCube = new THREE.CubeTextureLoader().load( urls );
				textureCube.format = THREE.RGBFormat;
				
				
				
				scene = new THREE.Scene();
				//scene.background = textureCube;
				//
				var geometry = new THREE.SphereGeometry( 100, 32, 16 );
				var shader = THREE.FresnelShader;
				var uniforms = THREE.UniformsUtils.clone( shader.uniforms );
				//uniforms[ "tCube" ].value = textureCube;
				var material = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader
				} );
				for ( var i = 0; i < 500; i ++ ) {
					var mesh = new THREE.Mesh( geometry, material );
					mesh.position.x = Math.random() * 10000 - 5000;
					mesh.position.y = Math.random() * 10000 - 5000;
					mesh.position.z = Math.random() * 10000 - 5000;
					mesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 3 + 1;
					scene.add( mesh );
					spheres.push( mesh );
				}
				//scene.matrixAutoUpdate = false;
				//
				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				//
				window.addEventListener( 'resize', onWindowResize, false );
			}
			function onWindowResize() {
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function onDocumentMouseMove( event ) {
				mouseX = ( event.clientX - windowHalfX ) * 10;
				mouseY = ( event.clientY - windowHalfY ) * 10;
			}
			//
			function animate() {
				requestAnimationFrame( animate );
				render();
			}
			function render() {
				var timer = 0.0001 * Date.now();
				camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( - mouseY - camera.position.y ) * .05;
				camera.lookAt( scene.position );
				for ( var i = 0, il = spheres.length; i < il; i ++ ) {
					var sphere = spheres[ i ];
					sphere.position.x = 5000 * Math.cos( timer + i );
					sphere.position.y = 5000 * Math.sin( timer + i * 1.1 );
				}
				renderer.render( scene, camera );
			}
		</script>

	</body>
</html>-->



<!--
<html> 
<head>
    <title>Test</title>  
</head>
<body>
    <script src="https://vk.com/js/api/xd_connection.js?2"  type="text/javascript"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.2.2/pixi.min.js"></script>
    <script src="test.js"  type="text/javascript"></script>
</body>
</html>
-->
-->



<!--
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Ammo.js Raycast vehicle demo</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                color: #61443e;
                font-family:Monospace;
                font-size:13px;
                text-align:center;
                background-color: #bfd1e5;
                margin: 0px;
                overflow: hidden;
            }
			#speedometer {
				color: #ffffff;
				background-color: #990000;
				position: absolute;
				bottom: 0px;
				padding: 5px;
			}
            #info {
                position: absolute;
                top: 0px; width: 100%;
                padding: 5px;
            }
            a {
                color: #a06851;
            }
        </style>
    </head>
    <body>
        <div id="container"><br /><br /><br /><br /><br />Loading...</div>
		<div id="speedometer">0.0 km/h</div>
        <div id="info">Ammo.js Raycast vehicle demo<br>Press W,A,S,D to move.</div>

		<script src="https://rawgit.com/kripken/ammo.js/master/builds/ammo.js"></script>
		

        <script src="https://rawgit.com/mrdoob/three.js/master/build/three.js"></script>
	<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js"></script>
        <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/libs/stats.min.js"></script>
	<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/DDSLoader.js"></script>

        <script>
		Ammo().then(function(Ammo) {



			// Detects webgl
			/*
			if ( ! Detector.webgl ) {
				Detector.addGetWebGLMessage();
				document.getElementById( 'container' ).innerHTML = "";
			}
			*/



			// - Global variables -
			var DISABLE_DEACTIVATION = 4;
			var TRANSFORM_AUX = new Ammo.btTransform();
			var ZERO_QUATERNION = new THREE.Quaternion(0, 0, 0, 1);
			// Graphics variables
			var container, stats, speedometer;
			var camera, controls, scene, renderer;
			var terrainMesh, texture;
			var clock = new THREE.Clock();
			var materialDynamic, materialStatic, materialInteractive;
			// Physics variables
			var collisionConfiguration;
			var dispatcher;
			var broadphase;
			var solver;
			var physicsWorld;
			var syncList = [];
			var time = 0;
			var objectTimePeriod = 3;
			var timeNextSpawn = time + objectTimePeriod;
			var maxNumObjects = 30;
			// Keybord actions
			var actions = {};
			var keysActions = {
				"KeyW":'acceleration',
				"KeyS":'braking',
				"KeyA":'left',
				"KeyD":'right'
			};



			// объявляем глобальные переменные для террейна
			var terrainWidthExtents = 100;
			var terrainDepthExtents = 100;
			var terrainWidth = 256;
			var terrainDepth = 256;
			var terrainHalfWidth = terrainWidth / 2;
			var terrainHalfDepth = terrainDepth / 2;
			var terrainMaxHeight = 2;
			var terrainMinHeight = -2;
			var terrainMesh;
			var heightData = null;
			var ammoHeightData = null;
			var DDS;


			var loader = new THREE.DDSLoader();
			DDS = loader.load(
				'mmm.dds',
				function() {
					console.log('DDS Loadedd');
					initGraphics();
					initPhysics();
					createObjects();
					tick();
				}
			);



			// - Functions -
			function initGraphics() {
				container = document.getElementById( 'container' );
				speedometer = document.getElementById( 'speedometer' );
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 2000 );
				camera.position.x = -4.84;
				camera.position.y = 4.39;
				camera.position.z = -35.11;
				camera.lookAt( new THREE.Vector3( 0.33, -0.40, 0.85 ) );
				controls = new THREE.OrbitControls( camera );
				renderer = new THREE.WebGLRenderer({antialias:true});
				renderer.setClearColor( 0xbfd1e5 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				var ambientLight = new THREE.AmbientLight( 0x404040 );
				scene.add( ambientLight );
				var dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
				dirLight.position.set( 10, 10, 5 );
				scene.add( dirLight );
				materialDynamic = new THREE.MeshPhongMaterial( { color:0xfca400 } );
				materialStatic = new THREE.MeshPhongMaterial( { color:0x999999 } );
				materialInteractive=new THREE.MeshPhongMaterial( { color:0x990000 } );
				


				heightData = TerrainGeometry('mipTest0.dds', 'mono:g', 256, 1, -2, 2, 0);
				// объявляем массив высот и рисуем террейн
				
				//heightData = generateHeight( terrainWidth, terrainDepth, terrainMinHeight, terrainMaxHeight );
				var geometry = new THREE.PlaneBufferGeometry( 100, 100, terrainWidth - 1, terrainDepth - 1 );
				geometry.rotateX( - Math.PI / 2 );
				var vertices = geometry.attributes.position.array;
				for ( var i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {
					vertices[ j + 1 ] = heightData[ i ];
				}
				geometry.computeVertexNormals();
				var groundMaterial = new THREE.MeshPhongMaterial( { color: 0xC7C7C7 } );
				terrainMesh = new THREE.Mesh( geometry, groundMaterial );
				scene.add( terrainMesh );
				



				

				function TerrainGeometry(heightMap, heightType, bySize, quality, heightMin, heightMax, heightMedian) {
					//var loader = new THREE.DDSLoader();
					//DDS = loader.load(heightMap);



					var qSelect = Math.round(DDS.mipmaps.length * (1 - quality)) - 1;
					if (qSelect < 0) qSelect = 0;

					
					var width = DDS.mipmaps[qSelect].width;
					var height = DDS.mipmaps[qSelect].height;



					//var geometry = new THREE.PlaneBufferGeometry(bySize, bySize, width - 1, height - 1);
					//var vertices = geometry.attributes.position.array;


					var vertices = new Float32Array( width*height );

					var startPos;
					if(heightType=='mono:r') startPos = 0;
					if(heightType=='mono:g') startPos = 1;
					if(heightType=='mono:b') startPos = 2;
					if(heightType=='mono:a') startPos = 3;
					var len = DDS.mipmaps[qSelect].data.length;
					var array = [];
					console.log(len);
					for(var i=0; i<(len/4 - 1); i++) {
						array[i] = DDS.mipmaps[qSelect].data[i*4 + startPos];
					}
					var min = min(array);
					var max = max(array);
					
					
					function min(array) {
						var mm = array[0];
						for(var i=1; i<array.length; i++) {
							if (array[i]<=mm) mm = array[i];
						}
						return mm;
					}
					function max(array) {
						var mm = array[0];
						for(var i=1; i<array.length; i++) {
							if (array[i]>=mm) mm = array[i];
						}
						return mm;
					}
					
					
					
					var med = (max + min)/2;

					for (var i=0; i<(len/4 - 1); i++) {
						var value = array[i];
						if (value < med) {
							vertices[i] = heightMin + (heightMedian - heightMin)*(value - min)/(med - min);
						} else {

							vertices[i] = heightMedian + (heightMax - heightMedian)*(value - med)/(max - med);
						}						
					}
					//geometry.computeVertexNormals();
					//var groundMaterial = new THREE.MeshPhongMaterial( { color: 0xC7C7C7 } );
					//terrainMesh = new THREE.Mesh( geometry, groundMaterial );
					//scene.add( terrainMesh );
					return vertices;

				}




				container.innerHTML = "";
				container.appendChild( renderer.domElement );
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );
				window.addEventListener( 'resize', onWindowResize, false );
				window.addEventListener( 'keydown', keydown);
				window.addEventListener( 'keyup', keyup);
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function initPhysics() {
				// Physics configuration
				collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
				dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );
				broadphase = new Ammo.btDbvtBroadphase();
				solver = new Ammo.btSequentialImpulseConstraintSolver();
				physicsWorld = new Ammo.btDiscreteDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration );
				physicsWorld.setGravity( new Ammo.btVector3( 0, -9.82, 0 ) );



				// Создаём физическое тело террейна
				var groundShape = createTerrainShape( heightData );
				var groundTransform = new Ammo.btTransform();
	  			groundTransform.setIdentity();
	  			// Shifts the terrain, since bullet re-centers it on its bounding box.
	  			groundTransform.setOrigin( new Ammo.btVector3( 0, ( terrainMaxHeight + terrainMinHeight ) / 2, 0 ) );
				var groundMass = 0;
				var groundLocalInertia = new Ammo.btVector3( 0, 0, 0 );
	  			var groundMotionState = new Ammo.btDefaultMotionState( groundTransform );
	    			var groundBody = new Ammo.btRigidBody( new Ammo.btRigidBodyConstructionInfo( groundMass, groundMotionState, groundShape, groundLocalInertia ) );
				physicsWorld.addRigidBody( groundBody );
			}



			// создание физической формы террейна
			function createTerrainShape() {
				// This parameter is not really used, since we are using PHY_FLOAT height data type and hence it is ignored
				var heightScale = 1;
				// Up axis = 0 for X, 1 for Y, 2 for Z. Normally 1 = Y is used.
				var upAxis = 1;
				// hdt, height data type. "PHY_FLOAT" is used. Possible values are "PHY_FLOAT", "PHY_UCHAR", "PHY_SHORT"
				var hdt = "PHY_FLOAT";
				// Set this to your needs (inverts the triangles)
				var flipQuadEdges = false;
				// Creates height data buffer in Ammo heap
				ammoHeightData = Ammo._malloc( 4 * terrainWidth * terrainDepth );
				// Copy the javascript height data array to the Ammo one.
				var p = 0;
				var p2 = 0;
				for ( var j = 0; j < terrainDepth; j ++ ) {
					for ( var i = 0; i < terrainWidth; i ++ ) {
						// write 32-bit float data to memory
						Ammo.HEAPF32[ammoHeightData + p2 >> 2] = heightData[ p ];
						p ++;
						// 4 bytes/float
						p2 += 4;
					}
				}
				// Creates the heightfield physics shape
				var heightFieldShape = new Ammo.btHeightfieldTerrainShape(
					terrainWidth,
					terrainDepth,
					ammoHeightData,
					heightScale,
					terrainMinHeight,
					terrainMaxHeight,
					upAxis,
					hdt,
					flipQuadEdges
				);
				// Set horizontal scale
				var scaleX = terrainWidthExtents / ( terrainWidth - 1 );
				var scaleZ = terrainDepthExtents / ( terrainDepth - 1 );
				heightFieldShape.setLocalScaling( new Ammo.btVector3( scaleX, 1, scaleZ ) );
				heightFieldShape.setMargin( 0.05 );
				return heightFieldShape;
            		}



			// Генерация высот точек для объявления террейна
			function generateHeight( width, depth, minHeight, maxHeight ) {
            			// Generates the height data (a sinus wave)
                		var size = width * depth;
                		var data = new Float32Array( size );
                		var hRange = maxHeight - minHeight;
                		var w2 = width / 2;
                		var d2 = depth / 2;
                		var phaseMult = 12;
				var p = 0;
                		for ( var j = 0; j < depth; j ++ ) {
                			for ( var i = 0; i < width; i ++ ) {
                				var radius = Math.sqrt(
                					Math.pow( ( i - w2 ) / w2, 2.0 ) +
                					Math.pow( ( j - d2 ) / d2, 2.0 ) );
						var height = ( Math.sin( radius * phaseMult ) + 1 ) * 0.5  * hRange + minHeight;
						data[ p ] = height;
						p++;
					}
                		}
                		return data;
            		}




			function tick() {
				requestAnimationFrame( tick );
				var dt = clock.getDelta();
				for (var i = 0; i < syncList.length; i++)
					syncList[i](dt);
				physicsWorld.stepSimulation( dt, 10 );
				controls.update( dt );
				renderer.render( scene, camera );
				time += dt;
				stats.update();
			}
			function keyup(e) {
				if(keysActions[e.code]) {
					actions[keysActions[e.code]] = false;
					e.preventDefault();
					e.stopPropagation();
					return false;
				}
			}
			function keydown(e) {
				if(keysActions[e.code]) {
					actions[keysActions[e.code]] = true;
					e.preventDefault();
					e.stopPropagation();
					return false;
				}
			}
			function createBox(pos, quat, w, l, h, mass, friction) {
				var material = mass > 0 ? materialDynamic : materialStatic;
				var shape = new THREE.BoxGeometry(w, l, h, 1, 1, 1);
				var geometry = new Ammo.btBoxShape(new Ammo.btVector3(w * 0.5, l * 0.5, h * 0.5));
				if(!mass) mass = 0;
				if(!friction) friction = 1;
				var mesh = new THREE.Mesh(shape, material);
				mesh.position.copy(pos);
				mesh.quaternion.copy(quat);
				scene.add( mesh );
				var transform = new Ammo.btTransform();
				transform.setIdentity();
				transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
				transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
				var motionState = new Ammo.btDefaultMotionState(transform);
				var localInertia = new Ammo.btVector3(0, 0, 0);
				geometry.calculateLocalInertia(mass, localInertia);
				var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, geometry, localInertia);
				var body = new Ammo.btRigidBody(rbInfo);
				body.setFriction(friction);
				//body.setRestitution(.9);
				//body.setDamping(0.2, 0.2);
				physicsWorld.addRigidBody( body );
				if (mass > 0) {
					body.setActivationState(DISABLE_DEACTIVATION);
					// Sync physics and graphics
					function sync(dt) {
						var ms = body.getMotionState();
						if (ms) {
							ms.getWorldTransform(TRANSFORM_AUX);
							var p = TRANSFORM_AUX.getOrigin();
							var q = TRANSFORM_AUX.getRotation();
							mesh.position.set(p.x(), p.y(), p.z());
							mesh.quaternion.set(q.x(), q.y(), q.z(), q.w());
						}
					}
					syncList.push(sync);
				}
			}
			function createWheelMesh(radius, width) {
				var t = new THREE.CylinderGeometry(radius, radius, width, 24, 1);
				t.rotateZ(Math.PI / 2);
				var mesh = new THREE.Mesh(t, materialInteractive);
				mesh.add(new THREE.Mesh(new THREE.BoxGeometry(width * 1.5, radius * 1.75, radius*.25, 1, 1, 1), materialInteractive));
				scene.add(mesh);
				return mesh;
			}
			function createChassisMesh(w, l, h) {
				var shape = new THREE.BoxGeometry(w, l, h, 1, 1, 1);
				var mesh = new THREE.Mesh(shape, materialInteractive);
				scene.add(mesh);
				return mesh;
			}
			function createVehicle(pos, quat) {
				// Vehicle contants
				var chassisWidth = 1.8;
				var chassisHeight = .6;
				var chassisLength = 4;
				var massVehicle = 800;
				var wheelAxisPositionBack = -1;
				var wheelRadiusBack = .4;
				var wheelWidthBack = .3;
				var wheelHalfTrackBack = 1;
				var wheelAxisHeightBack = .3;
				var wheelAxisFrontPosition = 1.7;
				var wheelHalfTrackFront = 1;
				var wheelAxisHeightFront = .3;
				var wheelRadiusFront = .35;
				var wheelWidthFront = .2;
				var friction = 1000;
				var suspensionStiffness = 20.0;
				var suspensionDamping = 2.3;
				var suspensionCompression = 4.4;
				var suspensionRestLength = 0.6;
				var rollInfluence = 0.2;
				var steeringIncrement = .04;
				var steeringClamp = .5;
				var maxEngineForce = 2000;
				var maxBreakingForce = 100;
				// Chassis
				var geometry = new Ammo.btBoxShape(new Ammo.btVector3(chassisWidth * .5, chassisHeight * .5, chassisLength * .5));
				var transform = new Ammo.btTransform();
				transform.setIdentity();
				transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
				transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
				var motionState = new Ammo.btDefaultMotionState(transform);
				var localInertia = new Ammo.btVector3(0, 0, 0);
				geometry.calculateLocalInertia(massVehicle, localInertia);
				var body = new Ammo.btRigidBody(new Ammo.btRigidBodyConstructionInfo(massVehicle, motionState, geometry, localInertia));
				body.setActivationState(DISABLE_DEACTIVATION);
				physicsWorld.addRigidBody(body);
				var chassisMesh = createChassisMesh(chassisWidth, chassisHeight, chassisLength);
				// Raycast Vehicle
				var engineForce = 0;
				var vehicleSteering = 0;
				var breakingForce = 0;
				var tuning = new Ammo.btVehicleTuning();
				var rayCaster = new Ammo.btDefaultVehicleRaycaster(physicsWorld);
				var vehicle = new Ammo.btRaycastVehicle(tuning, body, rayCaster);
				vehicle.setCoordinateSystem(0, 1, 2);
				physicsWorld.addAction(vehicle);
				// Wheels
				var FRONT_LEFT = 0;
				var FRONT_RIGHT = 1;
				var BACK_LEFT = 2;
				var BACK_RIGHT = 3;
				var wheelMeshes = [];
				var wheelDirectionCS0 = new Ammo.btVector3(0, -1, 0);
				var wheelAxleCS = new Ammo.btVector3(-1, 0, 0);
				function addWheel(isFront, pos, radius, width, index) {
					var wheelInfo = vehicle.addWheel(
							pos,
							wheelDirectionCS0,
							wheelAxleCS,
							suspensionRestLength,
							radius,
							tuning,
							isFront);
					wheelInfo.set_m_suspensionStiffness(suspensionStiffness);
					wheelInfo.set_m_wheelsDampingRelaxation(suspensionDamping);
					wheelInfo.set_m_wheelsDampingCompression(suspensionCompression);
					wheelInfo.set_m_frictionSlip(friction);
					wheelInfo.set_m_rollInfluence(rollInfluence);
					wheelMeshes[index] = createWheelMesh(radius, width);
				}
				addWheel(true, new Ammo.btVector3(wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_LEFT);
				addWheel(true, new Ammo.btVector3(-wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_RIGHT);
				addWheel(false, new Ammo.btVector3(-wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_LEFT);
				addWheel(false, new Ammo.btVector3(wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_RIGHT);
				// Sync keybord actions and physics and graphics
				function sync(dt) {
					var speed = vehicle.getCurrentSpeedKmHour();
					speedometer.innerHTML = (speed < 0 ? '(R) ' : '') + Math.abs(speed).toFixed(1) + ' km/h';
					breakingForce = 0;
					engineForce = 0;
					if (actions.acceleration) {
						if (speed < -1)
							breakingForce = maxBreakingForce;
						else engineForce = maxEngineForce;
					}
					if (actions.braking) {
						if (speed > 1)
							breakingForce = maxBreakingForce;
						else engineForce = -maxEngineForce / 2;
					}
					if (actions.left) {
						if (vehicleSteering < steeringClamp)
							vehicleSteering += steeringIncrement;
					}
					else {
						if (actions.right) {
							if (vehicleSteering > -steeringClamp)
								vehicleSteering -= steeringIncrement;
						}
						else {
							if (vehicleSteering < -steeringIncrement)
								vehicleSteering += steeringIncrement;
							else {
								if (vehicleSteering > steeringIncrement)
									vehicleSteering -= steeringIncrement;
								else {
									vehicleSteering = 0;
								}
							}
						}
					}
					vehicle.applyEngineForce(engineForce, BACK_LEFT);
					vehicle.applyEngineForce(engineForce, BACK_RIGHT);
					vehicle.setBrake(breakingForce / 2, FRONT_LEFT);
					vehicle.setBrake(breakingForce / 2, FRONT_RIGHT);
					vehicle.setBrake(breakingForce, BACK_LEFT);
					vehicle.setBrake(breakingForce, BACK_RIGHT);
					vehicle.setSteeringValue(vehicleSteering, FRONT_LEFT);
					vehicle.setSteeringValue(vehicleSteering, FRONT_RIGHT);
					var tm, p, q, i;
					var n = vehicle.getNumWheels();
					for (i = 0; i < n; i++) {
						vehicle.updateWheelTransform(i, true);
						tm = vehicle.getWheelTransformWS(i);
						p = tm.getOrigin();
						q = tm.getRotation();
						wheelMeshes[i].position.set(p.x(), p.y(), p.z());
						wheelMeshes[i].quaternion.set(q.x(), q.y(), q.z(), q.w());
					}
					tm = vehicle.getChassisWorldTransform();
					p = tm.getOrigin();
					q = tm.getRotation();
					chassisMesh.position.set(p.x(), p.y(), p.z());
					chassisMesh.quaternion.set(q.x(), q.y(), q.z(), q.w());
				}
				syncList.push(sync);
			}
			function createObjects() {
				//createBox(new THREE.Vector3(0, -0.5, 0), ZERO_QUATERNION, 75, 1, 75, 0, 2);
				var quaternion = new THREE.Quaternion(0, 0, 0, 1);
				quaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 18);
				//createBox(new THREE.Vector3(0, -1.5, 0), quaternion, 8, 4, 10, 0);
				var size = .75;
				var nw = 8;
				var nh = 6;
				for (var j = 0; j < nw; j++)
					for (var i = 0; i < nh; i++)
						createBox(new THREE.Vector3(size * j - (size * (nw - 1)) / 2, size * i, 10), ZERO_QUATERNION, size, size, size, 100);
				createVehicle(new THREE.Vector3(0, 4, -20), ZERO_QUATERNION);
			}
			// - Init -
			//initGraphics();
			//initPhysics();
			//createObjects();
			//tick();
		});
        </script>
    </body>
</html>
-->
<!--
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Ammo.js Raycast vehicle demo</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                color: #61443e;
                font-family:Monospace;
                font-size:13px;
                text-align:center;
                background-color: #bfd1e5;
                margin: 0px;
                overflow: hidden;
            }
			#speedometer {
				color: #ffffff;
				background-color: #990000;
				position: absolute;
				bottom: 0px;
				padding: 5px;
			}
            #info {
                position: absolute;
                top: 0px; width: 100%;
                padding: 5px;
            }
            a {
                color: #a06851;
            }
        </style>
    </head>
    <body>
        <div id="container"><br /><br /><br /><br /><br />Loading...</div>
		<div id="speedometer">0.0 km/h</div>
        <div id="info">Ammo.js Raycast vehicle demo<br>Press W,A,S,D to move.</div>

		<script src="https://rawgit.com/kripken/ammo.js/master/builds/ammo.js"></script>
		

        <script src="https://rawgit.com/mrdoob/three.js/master/build/three.js"></script>
	<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js"></script>
        <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/libs/stats.min.js"></script>
	<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/DDSLoader.js"></script>
	<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/libs/dat.gui.min.js"></script>

        <script>
		// Ammo().then(function(Ammo) {			
			
			
			// Graphics variables
			var container, stats;
			var camera, controls, scene, renderer;			
			var clock = new THREE.Clock();
			
			
			// объявляем глобальные переменные для террейна
			var DDS_width, DDS_height, terrainMesh, geometryTerrain;


			// изменение параметров heightType, quality я не добавил в GUI по причине неведомой херни
			var params = {
				heightType: "mono:g",
				sizeMap: 256,
				heightMin: -2,
				heightMax: 2,
				heightMedian: 0
			};			
			

			// загружаем карту высот
			var DDS;
			var loader = new THREE.DDSLoader();
			DDS = loader.load(
				'mmm.dds',
				function() {
					DDS_width = DDS.mipmaps[0].width;
					DDS_height = DDS.mipmaps[0].height;
					initScene();
					tick();
				}
			);


			function initScene() {

				// инициализируем сцену, камеру, рендерный движок
				container = document.getElementById( 'container' );
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 2000 );
				camera.position.x = -4.84;
				camera.position.y = 4.39;
				camera.position.z = -35.11;
				camera.lookAt( new THREE.Vector3( 0.33, -0.40, 0.85 ) );
				controls = new THREE.OrbitControls( camera );
				renderer = new THREE.WebGLRenderer({antialias:true});
				renderer.setClearColor( 0xbfd1e5 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				// добавляем источники освещения
				var ambientLight = new THREE.AmbientLight( 0x404040 );
				scene.add( ambientLight );
				var dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
				dirLight.position.set( 10, 10, 5 );
				scene.add( dirLight );

				// добавляем отображаемый Terrain				
				heightData = TerrainData(params);
				geometryTerrain = new THREE.PlaneBufferGeometry(params.sizeMap, params.sizeMap, DDS_width - 1, DDS_height - 1);
				geometryTerrain.rotateX( - Math.PI / 2 );
				var vertices = geometryTerrain.attributes.position.array;
				for ( var i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {
					vertices[ j + 1 ] = heightData[ i ];
				}
				geometryTerrain.computeVertexNormals();
				var groundMaterial = new THREE.MeshPhongMaterial( { color: 0xC7C7C7 } );
				terrainMesh = new THREE.Mesh( geometryTerrain, groundMaterial );
				scene.add( terrainMesh );

				// добавляем рендерный движок и статистику в документ
				container.innerHTML = "";
				container.appendChild( renderer.domElement );
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );
				window.addEventListener( 'resize', onWindowResize, false );
				


				var gui = new dat.GUI( { width: 400 } );
				gui.add( params, 'heightType', [ 'mono:a', 'mono:g', 'mono:b', 'mono:r' ] );
				gui.add( params, 'sizeMap', 1, 1024 );							
				gui.add( params, 'heightMin', -50, 50 );
				gui.add( params, 'heightMax', -50, 50 );
				gui.add( params, 'heightMedian', -50, 50 );
				gui.open();				

			}


			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onKey() {
				
				reOptionTerrain(); // перерасчёт террейна при всевозможном изменении параметров его отображения
			}			


			function tick() {
				window.addEventListener( 'keypress', onKey, false );
				requestAnimationFrame( tick );
				var dt = clock.getDelta();
				
				controls.update( dt );
				renderer.render( scene, camera );
				
				
				stats.update();
			}


			function TerrainData (params) {
				
				var heightType = params.heightType;				
				var heightMin = params.heightMin;
				var heightMax = params.heightMax;
				var heightMedian = params.heightMedian;				
				
				// рассчет высот по каналу считывания
				var startPos;
				if(heightType == 'mono:r') startPos = 0;
				if(heightType == 'mono:g') startPos = 1;
				if(heightType == 'mono:b') startPos = 2;
				if(heightType == 'mono:a') startPos = 3;
				
				// считывание цветов с выбранного mipmap-a
				var array = new Float32Array(DDS_width * DDS_height);
				var len = DDS.mipmaps[0].data.length;
				for(var i = 0; i < (len/4 - 1); i++) {
					array[i] = DDS.mipmaps[0].data[i*4 + startPos];
				}

				// перерасчёт высот на основе цветов
				var min = minArr(array);
				var max = maxArr(array);
				var med = (max + min)/2;
				for (var i = 0; i < (len/4 - 1); i++) {
					var value = array[i];
					if (value < med) {
						array[i] = heightMin + (heightMedian - heightMin)*(value - min)/(med - min);
					} else {
						array[i] = heightMedian + (heightMax - heightMedian)*(value - med)/(max - med);
					}						
				}

				return array; // возвращаем массив высот карты
					
				// функция минимального числа в массиве
				function minArr(array) {
					var min = array[0];
					for (var i = 1; i < array.length; i++) {
						if (array[i] <= min) min = array[i];
					}
					return min;
				}

				// функция максимального числа в массиве
				function maxArr(array) {
					var max = array[0];
					for (var i = 1; i < array.length; i++) {
						if (array[i] >= max) max = array[i];
					}
					return max;
				}					
					
			}


			function reOptionTerrain() {

				heightData = TerrainData(params);				
				var geometry = new THREE.PlaneBufferGeometry(params.sizeMap, params.sizeMap, DDS_width - 1, DDS_height - 1);
				geometry.rotateX( - Math.PI / 2 );
				var vertices = geometry.attributes.position.array;
				for ( var i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {
					vertices[ j + 1 ] = heightData[ i ];
				}
				geometry.computeVertexNormals();
				terrainMesh.geometry.dispose();				
				terrainMesh.geometry = geometry;

			}

		// });
        </script>
    </body>
</html>
-->







<!--
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - OBJLoader + MTLLoader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
			#info a, .button { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
		</style>
	</head>

	<body>
		<div id="info">
		<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - OBJLoader + MTLLoader
		</div>

		<script src="https://rawgit.com/mrdoob/three.js/master/build/three.js"></script>
		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/DDSLoader.js"></script>
		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/MTLLoader.js"></script>
		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/OBJLoader.js"></script>
		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/libs/stats.min.js"></script>
		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js"></script>
		
		
		
		

		<script>
			var container, stats;
			var camera, scene, renderer;
			var mouseX = 0, mouseY = 0;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			var obb, ambient, directionalLight;
			init();
			animate();
			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.z = 5;
				controls = new THREE.OrbitControls( camera );
				controls.minDistance = 0;
				controls.maxDistance = 100;
				// scene
				scene = new THREE.Scene();
				ambient = new THREE.AmbientLight( 0x444444 );
				scene.add( ambient );
				directionalLight = new THREE.DirectionalLight( 0xffeedd );
				directionalLight.position.set( 0, 10, 1 ).normalize();
				scene.add( directionalLight );
				// model
				var onProgress = function ( xhr ) {
					if ( xhr.lengthComputable ) {
						var percentComplete = xhr.loaded / xhr.total * 100;
						console.log( Math.round(percentComplete, 2) + '% downloaded' );
					}
				};
				var onError = function ( xhr ) { };
				THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader() );
				var mtlLoader = new THREE.MTLLoader();
				//mtlLoader.setPath( 'obj/male02/' );
				mtlLoader.load( 'yyy.mtl', function( materials ) {
					materials.preload();
					var objLoader = new THREE.OBJLoader();
					objLoader.setMaterials( materials );
					//objLoader.setPath( 'obj/male02/' );
					objLoader.load( 'yyy.obj', function ( object ) {
						//object.position.y = - 95;
						obb = object;
						scene.add( obb );
					}, onProgress, onError );
				});
				//
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				//
				window.addEventListener( 'resize', onWindowResize, false );
			}
			function onWindowResize() {
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function onDocumentMouseMove( event ) {
				mouseX = ( event.clientX - windowHalfX ) / 2;
				mouseY = ( event.clientY - windowHalfY ) / 2;
			}
			//
			function animate() {
				requestAnimationFrame( animate );
				render();
			}
			function render() {				
				camera.lookAt( scene.position );
				controls.update();
				renderer.render( scene, camera );
			}
		</script>

	</body>
</html>
-->











<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Ammo.js Raycast vehicle demo</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                color: #61443e;
                font-family:Monospace;
                font-size:13px;
                text-align:center;
                background-color: #bfd1e5;
                margin: 0px;
                overflow: hidden;
            }
			#speedometer {
				color: #ffffff;
				background-color: #990000;
				position: absolute;
				bottom: 0px;
				padding: 5px;
			}
            #info {
                position: absolute;
                top: 0px; width: 100%;
                padding: 5px;
            }
            a {
                color: #a06851;
            }
        </style>
    </head>
    <body>
        <div id="container"><br /><br /><br /><br /><br />Loading...</div>
		<div id="speedometer">0.0 km/h</div>
        <div id="info">Ammo.js Raycast vehicle demo<br>Press W,A,S,D to move.</div>

	
	<script id="planeVS" type="shader">
		precision highp float;

		uniform float		u_amplitude;
		uniform float 	u_frequency;
		uniform float   u_time;

		//
		// https://github.com/hughsk/glsl-noise/blob/master/classic/3d.glsl
		//
		// GLSL textureless classic 3D noise "cnoise",
		// with an RSL-style periodic variant "pnoise".
		// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
		// Version: 2011-10-11
		//
		// Many thanks to Ian McEwan of Ashima Arts for the
		// ideas for permutation and gradient selection.
		//
		// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
		// Distributed under the MIT license. See LICENSE file.
		// https://github.com/ashima/webgl-noise
		//

		vec3 mod289(vec3 x)
		{
			return x - floor(x * (1.0 / 289.0)) * 289.0;
		}

		vec4 mod289(vec4 x)
		{
			return x - floor(x * (1.0 / 289.0)) * 289.0;
		}

		vec4 permute(vec4 x)
		{
			return mod289(((x*34.0)+1.0)*x);
		}

		vec4 taylorInvSqrt(vec4 r)
		{
			return 1.79284291400159 - 0.85373472095314 * r;
		}

		vec3 fade(vec3 t) {
			return t*t*t*(t*(t*6.0-15.0)+10.0);
		}

		// Classic Perlin noise
		float cnoise(vec3 P)
		{
			vec3 Pi0 = floor(P); // Integer part for indexing
			vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
			Pi0 = mod289(Pi0);
			Pi1 = mod289(Pi1);
			vec3 Pf0 = fract(P); // Fractional part for interpolation
			vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
			vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
			vec4 iy = vec4(Pi0.yy, Pi1.yy);
			vec4 iz0 = Pi0.zzzz;
			vec4 iz1 = Pi1.zzzz;

			vec4 ixy = permute(permute(ix) + iy);
			vec4 ixy0 = permute(ixy + iz0);
			vec4 ixy1 = permute(ixy + iz1);

			vec4 gx0 = ixy0 * (1.0 / 7.0);
			vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
			gx0 = fract(gx0);
			vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
			vec4 sz0 = step(gz0, vec4(0.0));
			gx0 -= sz0 * (step(0.0, gx0) - 0.5);
			gy0 -= sz0 * (step(0.0, gy0) - 0.5);

			vec4 gx1 = ixy1 * (1.0 / 7.0);
			vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
			gx1 = fract(gx1);
			vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
			vec4 sz1 = step(gz1, vec4(0.0));
			gx1 -= sz1 * (step(0.0, gx1) - 0.5);
			gy1 -= sz1 * (step(0.0, gy1) - 0.5);

			vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
			vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
			vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
			vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
			vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
			vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
			vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
			vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

			vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
			g000 *= norm0.x;
			g010 *= norm0.y;
			g100 *= norm0.z;
			g110 *= norm0.w;
			vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
			g001 *= norm1.x;
			g011 *= norm1.y;
			g101 *= norm1.z;
			g111 *= norm1.w;

			float n000 = dot(g000, Pf0);
			float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
			float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
			float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
			float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
			float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
			float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
			float n111 = dot(g111, Pf1);

			vec3 fade_xyz = fade(Pf0);
			vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
			vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
			float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
			return 2.2 * n_xyz;
		}

		void main() {

			float displacement = u_amplitude * cnoise( u_frequency * position + u_time );

			vec3 newPosition = position + normal * displacement;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );

		}
	</script>

	<script id="planeFS" type="shader">
	precision highp float;
	void main() {
    		gl_FragColor = vec4(0.0, 0.0, 0.8, 1.0);
	}
	</script>
		

        <script src="https://rawgit.com/mrdoob/three.js/master/build/three.js"></script>
	<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js"></script>
	<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/WaterShader.js"></script>
	<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/SkyShader.js"></script>
        <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/libs/stats.min.js"></script>
	<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/DDSLoader.js"></script>
	<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/libs/dat.gui.min.js"></script>
	<script src="https://cdn.rawgit.com/zz85/zz85-bookmarklets/master/js/ThreeInspector.js"></script>
        <script>
		// Ammo().then(function(Ammo) {			
			
			
			// Graphics variables
			var container, stats;
			var camera, controls, scene, renderer;			
			var clock = new THREE.Clock();
			
			
			// объявляем глобальные переменные для террейна, воды и неба
			var terrainMesh, geometryTerrain;
			var water, geometryWater, mirrorMesh, offsetX_Water = 0, offsetY_Water = 0;			
			var sunSphere, sky;

		
			// параметры глобальных объектов карты
			var parametersOBJ = {
				
				WaterPlane: {
					size: 512,
					segments: 32,
					height: 8,
					heightScale: 1,
					speedX: 0.001,
					speedY: 0,
					material: {
						normalMap: 'waternormals.jpg',
						repeatTexture: 1,
						alpha: 1,
						sunColor: 0xffffff,
						waterColor: 0x001e0f,
						distortionScale: 50.0 // масштаб искажения
					}
				},
				
				Terrain: {
					src: 'mapH.png',
					size: 512,
					heightMin: 0,
					heightMax: 50,
					material: {
						map: 'mapT.jpg',
						normalMap: 'mapTnormal.jpg',
						repeatTexture: 96,
						color: 0x725C47,
						specular: 0xB79373,
						shininess: 1.4						
					}
				},
				
				Sky: {
					turbidity: 10,
					rayleigh: 2,
					mieCoefficient: 0.005,
					mieDirectionalG: 0.8,
					luminance: 1,
					inclination: 0.49, // elevation / inclination
					azimuth: 0.25, // Facing front,
					sun: ! true,
					distanceSun: 400000,
					lensFlare: false
				}
			
			};
		
		
			var heightMAP = new Image();
			heightMAP.onload = function () {
				initScene();
				tick();	
			};
			heightMAP.src = parametersOBJ.Terrain.src;
		
		

			function initScene() {

				// инициализируем сцену, камеру, рендерный движок
				container = document.getElementById( 'container' );
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.2, 2000000);
				camera.position.x = -4.84;
				camera.position.y = 4.39;
				camera.position.z = -35.11;
				camera.lookAt(new THREE.Vector3(0.33, -0.40, 0.85));
				controls = new THREE.OrbitControls(camera);				
				renderer = new THREE.WebGLRenderer(); //{antialias:true}				
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);

				
				// добавляем источники освещения
				var ambientLight = new THREE.AmbientLight( 0x404040 );
				scene.add( ambientLight );
				var dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
				dirLight.position.set( 10, 10, 5 );
				scene.add( dirLight );

				
				// добавляем отображаемый Terrain
				var inf = parametersOBJ.Terrain;
				heightData = getHeightData(heightMAP, inf);
				geometryTerrain = createTerrainMesh(heightMAP, heightData, inf);				
				var textureLoader = new THREE.TextureLoader();
				var map = textureLoader.load(inf.material.map);
				var normal = textureLoader.load(inf.material.normalMap);
				map.wrapS = map.wrapT = THREE.RepeatWrapping;
				normal.wrapS = normal.wrapT = THREE.RepeatWrapping;
				var repeat = inf.material.repeatTexture;
				if (repeat > 1) {
					map.repeat.set(repeat, repeat);
					normal.repeat.set(repeat, repeat);
				}
				var material = new THREE.MeshPhongMaterial( {
					color:		inf.material.color,
					specular:	inf.material.specular,
					shininess:	inf.material.shininess,
					map:		map,	
					normalMap:	normal,
					normalScale:	new THREE.Vector2( 0.8, 0.8 )
				} );
				terrainMesh = new THREE.Mesh(geometryTerrain, material);
				scene.add(terrainMesh);
				
				
				// добавляем водяную плоскость
				var inf = parametersOBJ.WaterPlane;
				var waterNormals = new THREE.TextureLoader().load(inf.material.normalMap);
				waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;
				var repeat = inf.material.repeatTexture;
				if (repeat > 1) waterNormals.repeat.set(repeat, repeat);
				water = new THREE.Water( renderer, camera, scene, {
					textureWidth:	inf.size,
					textureHeight:	inf.size,
					waterNormals:	waterNormals,
					alpha:		inf.material.alpha,
					sunDirection:	dirLight.position.clone().normalize(),
					sunColor:	inf.material.sunColor,
					waterColor:	inf.material.waterColor,
					distortionScale:inf.material.distortionScale,
					fog:		scene.fog != undefined
				} );
				var M = inf.size;
				var N = inf.segments;				
				geometryWater = new THREE.PlaneGeometry(M, M, N - 1, N - 1);
				var k = 0;
				var h = inf.height;
				var hS = inf.heightScale;				
				for (var i = 0; i < N; i++) {
					for (var j = 0; j < N; j++) {						
						geometryWater.vertices[k].x = (i - N/2) * M/N;
						geometryWater.vertices[k].y = (Math.cos((i/N) * Math.PI*h) + Math.sin((j/N) * Math.PI*h)) / hS;
						geometryWater.vertices[k].z = (j - N/2) * M/N;
						k++;
					}
				}
				mirrorMesh = new THREE.Mesh(geometryWater, water.material);
				mirrorMesh.rotation.x = Math.PI;
				mirrorMesh.add(water);				
				scene.add(mirrorMesh);
				
				
				// добавляем небо
				var inf = parametersOBJ.Sky;
				sky = new THREE.Sky();
				scene.add(sky.mesh);				
				sunSphere = new THREE.Mesh(
					new THREE.SphereBufferGeometry(20000, 16, 8),
					new THREE.MeshBasicMaterial( { color: 0xffffff } )
				);
				sunSphere.position.y = - 700000;
				sunSphere.visible = false;
				scene.add(sunSphere);				
				var distance = inf.distanceSun;
				function settings_Sky() {
					var uniforms = sky.uniforms;
					uniforms.turbidity.value = inf.turbidity;
					uniforms.rayleigh.value = inf.rayleigh;
					uniforms.luminance.value = inf.luminance;
					uniforms.mieCoefficient.value = inf.mieCoefficient;
					uniforms.mieDirectionalG.value = inf.mieDirectionalG;
					var theta = Math.PI * (inf.inclination - 0.5);
					var phi = 2 * Math.PI * (inf.azimuth - 0.5);
					sunSphere.position.x = distance * Math.cos(phi);
					sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta);
					sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta);
					sunSphere.visible = inf.sun;
					sky.uniforms.sunPosition.value.copy(sunSphere.position);
					renderer.render(scene, camera);
				}				
				settings_Sky();
				
				
				// добавляем рендерный движок и статистику в документ
				container.innerHTML = "";
				container.appendChild(renderer.domElement);
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild(stats.domElement);
				window.addEventListener('resize', onWindowResize, false);				
				

				// добавляем интерфейс управления террейном
				var gui = new dat.GUI( { width: 400 } );
				/*
				gui.add( parametersOBJ, Terrain.size, 1, 1024 );
				gui.add( parametersOBJ, WaterPlane.size, 1, 1024 );
				gui.add( parametersOBJ, Terrain.heightMin, -50, 50 );
				gui.add( parametersOBJ, Terrain.heightMax, -50, 50 );
				gui.add( parametersOBJ, Terrain.shininess, 0, 10 );				
				gui.add( parametersOBJ, WaterPlane.height, 1, 50 );
				gui.add( parametersOBJ, WaterPlane.heightScale, 0, 50 );
				gui.add( parametersOBJ, WaterPlane.speedX, 0.001, 0.01 );
				gui.add( parametersOBJ, WaterPlane.speedY, 0.001, 0.01 );
				gui.add( parametersOBJ, WaterPlane.alpha, 0, 1 );
				gui.open();*/				

			}


			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

		
			// перерасчёт террейна при всевозможном изменении параметров его отображения
			function onKey() {reOptionTerrain();}			


			// рендер сцены
			function tick() {
				window.addEventListener( 'keypress', onKey, false );
				requestAnimationFrame( tick );
				var dt = clock.getDelta();							
				controls.update(dt);
				
				
				updateWaterPlane(parametersOBJ.WaterPlane);
				water.render();
				
				
				renderer.render( scene, camera );				
				stats.update();				
			}

		
			// считывание высот с изображения "карта высот" для террайна
			function getHeightData(img, parameters) {
				var minH = parameters.heightMin, maxH = parameters.heightMax;
				var canvas = document.createElement( 'canvas' );
				canvas.width = img.width;
				canvas.height = img.height;
				var size = canvas.width * canvas.height, data = new Float32Array(size);
				var context = canvas.getContext( '2d' );
				context.drawImage(img, 0, 0);
				var imgd = context.getImageData(0, 0, img.width, img.height);
				var pix = imgd.data;
				var height = maxH - minH, j = 0;
				for (var i = 0, n = pix.length; i < n; i += 4) {
					var all = (pix[i] + pix[i+1] + pix[i+2]) / 3;
					data[j++] = minH + (height * all/255);
				}
				return data;				
			}
		
		
			// создание геометрии террейна по массиву высот
			function createTerrainMesh(img, heightData, parameters) {
				var geometry = new THREE.PlaneBufferGeometry(parameters.size, parameters.size, img.width - 1, img.height - 1);
				geometry.rotateX(- Math.PI / 2);				
				var vertices = geometry.attributes.position.array;
				for (var i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3) {
					vertices[j + 1] = heightData[i];
				}
				geometry.computeVertexNormals();
				return geometry;
			}

		
			// обновление геометрии террейна (для активного изменения ландшафта через интерфейс)
			function reOptionTerrain() {
				heightData = getHeightData(heightMAP, parametersOBJ.Terrain);				
				var geometry = createTerrainMesh(heightMAP, heightData, parametersOBJ.Terrain);				
				terrainMesh.geometry.dispose();				
				terrainMesh.geometry = geometry;
			}
		
		
			// обновление шейдера и геометрии плоскости воды
			function updateWaterPlane(parameters) {
				var k = 0;
				var N = parameters.segments;
				var h = parameters.height;
				var hS = parameters.heightScale;
				for (var i = 0; i < N; i++) {
					for (var j = 0; j < N; j++) {												
						geometryWater.vertices[k].y = (Math.cos((offsetX_Water + i/N)*Math.PI*h) + Math.sin((offsetY_Water + j/N)*Math.PI*h)) / hS;
						k++;
					}
				}
				offsetX_Water += parameters.speedX;
				offsetY_Water += parameters.speedY;
				mirrorMesh.geometry.verticesNeedUpdate = true;				
				water.material.uniforms.time.value += 1.0 / 60.0;
			}
		
			

		// });
        </script>
    </body>
</html>
